"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const fs_1 = require("fs");
const resolveVue_1 = require("./resolveVue");
const serverPluginHmr_1 = require("./serverPluginHmr");
const resolve_from_1 = __importDefault(require("resolve-from"));
const chalk_1 = __importDefault(require("chalk"));
const resolver_1 = require("./resolver");
const debugBuild = require('debug')('vite:build');
const scriptRE = /<script\b[^>]*>([\s\S]*?)<\/script>/gm;
async function build({ root = process.cwd(), cdn = !resolveVue_1.resolveVue(root).hasLocalVue, cssFileName = 'style.css', resolvers = [], srcRoots = [], rollupInputOptions = {}, rollupOutputOptions = {}, write = true, minify = true, silent = false, rollupPluginVueOptions = {} } = {}) {
    process.env.NODE_ENV = 'production';
    const start = Date.now();
    // lazy require rollup so that we don't load it when only using the dev server
    // importing it just for the types
    const rollup = require('rollup').rollup;
    const indexPath = path_1.default.resolve(root, 'index.html');
    // make sure to use the same verison of vue from the CDN.
    const vueVersion = resolveVue_1.resolveVue(root).version;
    const cdnLink = `https://unpkg.com/vue@${vueVersion}/dist/vue.esm-browser.prod.js`;
    let indexContent = null;
    try {
        indexContent = await fs_1.promises.readFile(indexPath, 'utf-8');
    }
    catch (e) {
        // no index
    }
    const resolver = resolver_1.createResolver(root, resolvers);
    srcRoots.push(root);
    const vitePlugin = {
        name: 'vite',
        resolveId(id) {
            if (id === serverPluginHmr_1.hmrClientId) {
                return serverPluginHmr_1.hmrClientId;
            }
            else if (id.startsWith('/')) {
                // if id starts with any of the src root directories, it's a file request
                if (srcRoots.some((root) => id.startsWith(root))) {
                    return;
                }
                const resolved = resolver.requestToFile(id);
                debugBuild(`[resolve]`, id, `-->`, resolved);
                return resolved;
            }
            else if (id === 'vue') {
                if (!cdn) {
                    return resolveVue_1.resolveVue(root, true).vue;
                }
                else {
                    return {
                        id: cdnLink,
                        external: true
                    };
                }
            }
            else {
                const request = resolver.idToRequest(id);
                if (request) {
                    const resolved = resolver.requestToFile(request);
                    debugBuild(`[resolve]`, id, `-->`, request, `--> `, resolved);
                    return resolved;
                }
            }
        },
        load(id) {
            if (id === serverPluginHmr_1.hmrClientId) {
                return `export const hot = {}`;
            }
            else if (id === indexPath) {
                let script = '';
                if (indexContent) {
                    let match;
                    while ((match = scriptRE.exec(indexContent))) {
                        // TODO handle <script type="module" src="..."/>
                        // just add it as an import
                        script += match[1];
                    }
                }
                return script;
            }
        }
    };
    const styles = new Map();
    const cssExtractPlugin = {
        name: 'vite-css',
        transform(code, id) {
            if (id.endsWith('.css')) {
                styles.set(id, code);
                return '/* css extracted by vite */';
            }
        },
        async generateBundle(_options, bundle) {
            let css = '';
            // finalize extracted css
            styles.forEach((s) => {
                css += s;
            });
            // minify with cssnano
            if (minify) {
                css = (await require('postcss')([require('cssnano')]).process(css, {
                    from: undefined
                })).css;
            }
            bundle[cssFileName] = {
                isAsset: true,
                type: 'asset',
                fileName: cssFileName,
                source: css
            };
        }
    };
    const bundle = await rollup({
        input: path_1.default.resolve(root, 'index.html'),
        ...rollupInputOptions,
        plugins: [
            ...(rollupInputOptions.plugins || []),
            vitePlugin,
            require('rollup-plugin-vue')({
                // TODO: for now we directly handle pre-processors in rollup-plugin-vue
                // so that we don't need to install dedicated rollup plugins.
                // In the future we probably want to still use rollup plugins so that
                // preprocessors are also supported by importing from js files.
                preprocessStyles: true,
                preprocessCustomRequire: (id) => require(resolve_from_1.default(root, id)),
                // TODO proxy cssModules config
                ...rollupPluginVueOptions
            }),
            require('@rollup/plugin-node-resolve')({
                rootDir: root
            }),
            require('@rollup/plugin-replace')({
                'process.env.NODE_ENV': '"production"',
                __DEV__: 'false'
            }),
            cssExtractPlugin,
            ...(minify ? [require('rollup-plugin-terser').terser()] : [])
        ],
        onwarn(warning, warn) {
            if (warning.code !== 'CIRCULAR_DEPENDENCY') {
                warn(warning);
            }
        }
    });
    async function generate(options) {
        const outDir = options.dir || path_1.default.resolve(root, 'dist');
        const { output } = await bundle.generate({
            dir: outDir,
            format: 'es',
            ...options
        });
        let generatedIndex = indexContent && indexContent.replace(scriptRE, '').trim();
        // TODO handle public path for injections?
        // this would also affect paths in templates and css.
        if (generatedIndex) {
            // inject css link
            generatedIndex = injectCSS(generatedIndex, cssFileName);
            if (cdn) {
                // if not inlining vue, inject cdn link so it can start the fetch early
                generatedIndex = injectScript(generatedIndex, cdnLink);
            }
        }
        if (write) {
            await fs_1.promises.rmdir(outDir, { recursive: true });
            await fs_1.promises.mkdir(outDir, { recursive: true });
        }
        let css = '';
        // inject / write bundle
        for (const chunk of output) {
            if (chunk.type === 'chunk') {
                if (chunk.isEntry && generatedIndex) {
                    // inject chunk to html
                    generatedIndex = injectScript(generatedIndex, chunk.fileName);
                }
                // write chunk
                if (write) {
                    const filepath = path_1.default.join(outDir, chunk.fileName);
                    !silent &&
                        console.log(`write ${chalk_1.default.cyan(path_1.default.relative(process.cwd(), filepath))}`);
                    await fs_1.promises.mkdir(path_1.default.dirname(filepath), { recursive: true });
                    await fs_1.promises.writeFile(filepath, chunk.code);
                }
            }
            else {
                // write asset
                if (chunk.fileName === cssFileName) {
                    css = chunk.source.toString();
                }
                const filepath = path_1.default.join(outDir, chunk.fileName);
                !silent &&
                    console.log(`write ${chalk_1.default.magenta(path_1.default.relative(process.cwd(), filepath))}`);
                await fs_1.promises.mkdir(path_1.default.dirname(filepath), { recursive: true });
                await fs_1.promises.writeFile(filepath, chunk.source);
            }
        }
        if (write) {
            // write html
            if (generatedIndex) {
                const indexOutPath = path_1.default.join(outDir, 'index.html');
                !silent &&
                    console.log(`write ${chalk_1.default.green(path_1.default.relative(process.cwd(), indexOutPath))}`);
                await fs_1.promises.writeFile(indexOutPath, generatedIndex);
            }
        }
        return {
            js: output,
            html: generatedIndex || '',
            css
        };
    }
    let result;
    if (Array.isArray(rollupOutputOptions)) {
        result = [];
        // make sure to build sequentially for correct css extraction
        for (const options of rollupOutputOptions) {
            result.push(await generate(options));
        }
    }
    else {
        result = await generate(rollupOutputOptions);
    }
    !silent &&
        console.log(`Build completed in ${((Date.now() - start) / 1000).toFixed(2)}s.`);
    return result;
}
exports.build = build;
function injectCSS(html, filename) {
    const tag = `<link rel="stylesheet" href="./${filename}">`;
    if (/<\/head>/.test(html)) {
        return html.replace(/<\/head>/, `${tag}\n</head>`);
    }
    else {
        return tag + '\n' + html;
    }
}
function injectScript(html, filename) {
    filename = /^https?:\/\//.test(filename) ? filename : `./${filename}`;
    const tag = `<script type="module" src="${filename}"></script>`;
    if (/<\/body>/.test(html)) {
        return html.replace(/<\/body>/, `${tag}\n</body>`);
    }
    else {
        return html + '\n' + tag;
    }
}
