"use strict";
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
const path_1 = __importDefault(require("path"));
const gray_matter_1 = __importDefault(require("gray-matter"));
const lru_cache_1 = __importDefault(require("lru-cache"));
const markdown_1 = require("./markdown/markdown");
const parseHeader_1 = require("./utils/parseHeader");
const debug = require('debug')('vitepress:md');
const cache = new lru_cache_1.default({ max: 1024 });
function createMarkdownToVueRenderFn(root, options = {}) {
    const md = markdown_1.createMarkdownRenderer(options);
    return (src, file, lastUpdated, injectData = true) => {
        file = path_1.default.relative(root, file);
        const cached = cache.get(src);
        if (cached) {
            debug(`[cache hit] ${file}`);
            return cached;
        }
        const start = Date.now();
        const { content, data: frontmatter } = gray_matter_1.default(src);
        const { html, data } = md.render(content);
        // TODO validate data.links?
        // inject page data
        const pageData = {
            title: inferTitle(frontmatter, content),
            frontmatter,
            headers: data.headers,
            lastUpdated
        };
        const additionalBlocks = injectData
            ? injectPageData(data.hoistedTags || [], pageData)
            : data.hoistedTags || [];
        // double wrapping since tempalte root node is never hoisted or turned into
        // a static node.
        const vueSrc = `<template><div><div class="vitepress-content">${html}</div></div></template>\n` +
            additionalBlocks.join('\n');
        debug(`[render] ${file} in ${Date.now() - start}ms.`);
        const result = { vueSrc, pageData };
        cache.set(src, result);
        return result;
    };
}
exports.createMarkdownToVueRenderFn = createMarkdownToVueRenderFn;
const scriptRE = /<\/script>/;
function injectPageData(tags, data) {
    const code = `\nexport const __pageData = ${JSON.stringify(JSON.stringify(data))}`;
    const existingScriptIndex = tags.findIndex((tag) => scriptRE.test(tag));
    if (existingScriptIndex > -1) {
        tags[existingScriptIndex] = tags[existingScriptIndex].replace(scriptRE, code + `</script>`);
    }
    else {
        tags.push(`<script>${code}\nexport default {}</script>`);
    }
    return tags;
}
const inferTitle = (frontmatter, content) => {
    if (frontmatter.home) {
        return 'Home';
    }
    if (frontmatter.title) {
        return parseHeader_1.deeplyParseHeader(frontmatter.title);
    }
    const match = content.match(/^\s*#+\s+(.*)/m);
    if (match) {
        return parseHeader_1.deeplyParseHeader(match[1].trim());
    }
    return '';
};
